<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Cube Monster Park Hunt</title>
  <style>
    body {
      margin: 0;
      padding: 0;
      background-color: #000;
      overflow: hidden;
      font-family: 'Courier New', monospace;
    }
    canvas {
      display: block;
      margin: 0 auto;
      image-rendering: pixelated;
      image-rendering: crisp-edges;
    }
    .game-container {
      position: relative;
      width: 640px;
      margin: 20px auto;
    }
    .hud {
      color: #fff;
      padding: 10px;
      width: 100%;
      display: flex;
      flex-direction: column;
      gap: 5px;
      background-color: rgba(0, 0, 0, 0.7);
      border: 2px solid #ff0000;
      margin-bottom: 10px;
    }
    .hud-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .hud-item {
      display: flex;
      align-items: center;
      gap: 5px;
    }
    .hud-value {
      color: #ff0000;
      font-weight: bold;
    }
    .title {
      color: #ff0000;
      text-align: center;
      font-size: 24px;
      margin: 20px 0;
      text-shadow: 0 0 10px #ff0000;
      letter-spacing: 2px;
    }
    .game-over {
      display: none;
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: #ff0000;
      font-size: 36px;
      text-align: center;
      background-color: rgba(0, 0, 0, 0.8);
      padding: 20px;
      border: 2px solid #ff0000;
      width: 80%;
    }
    .restart {
      margin-top: 20px;
      padding: 10px 20px;
      background-color: #ff0000;
      color: #000;
      border: none;
      cursor: pointer;
      font-family: 'Courier New', monospace;
      font-size: 16px;
    }
    .version {
      color: #666;
      text-align: center;
      font-size: 12px;
      margin-top: 10px;
      font-family: 'Courier New', monospace;
    }
  </style>
</head>
<body>
  <h1 class="title">CUBE MONSTER PARK HUNT</h1>
  <div class="game-container">
    <div class="hud">
      <div class="hud-row">
        <div class="hud-item">LEVEL: <span id="levelName" class="hud-value">PARK</span></div>
        <div class="hud-item">ENERGY: <span id="energy" class="hud-value">100</span></div>
      </div>
      <div class="hud-row">
        <div class="hud-item">VICTIMS: <span id="score" class="hud-value">0</span>/<span id="requiredVictims" class="hud-value">5</span></div>
        <div class="hud-item">TOTAL: <span id="totalScore" class="hud-value">0</span></div>
      </div>
      <div id="speedBoost" class="hud-row" style="display: none;">
        <div class="hud-item">SPEED BOOST: <span id="boostTimer" class="hud-value">0</span>s</div>
      </div>
    </div>
    <canvas id="gameCanvas" width="640" height="480"></canvas>
    <div id="gameOver" class="game-over">
      <h2>GAME OVER</h2>
      <p>VICTIMS CONSUMED: <span id="finalScore">0</span></p>
      <button class="restart" onclick="restartGame()">HUNT AGAIN</button>
    </div>
    <div class="version">v1.0.3</div>
  </div>
  
  <script src="levels.js"></script>
  <script>
    // Game variables
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const scoreDisplay = document.getElementById('score');
    const energyDisplay = document.getElementById('energy');
    const gameOverScreen = document.getElementById('gameOver');
    const finalScoreDisplay = document.getElementById('finalScore');
    const speedBoostDisplay = document.getElementById('speedBoost');
    const boostTimerDisplay = document.getElementById('boostTimer');
    
    let score = 0;
    let energy = 100;
    let isGameOver = false;
    let gameTime = 0; // Track game time for enemy speed scaling
    
    // Player cube
    const player = {
      x: canvas.width / 2,
      y: canvas.height / 2,
      size: 32,
      color: '#ff0000',
      speed: 4,
      isFlickering: false,
      flickerCount: 0,
      pulseSize: 0,
      pulseDirection: 1,
      isInPond: false,
      hasSpeedBoost: false,
      speedBoostTimer: 0,
      invulnerabilityTimer: 0 // Temporary invulnerability after taking damage
    };
    
    // Victims array
    let victims = [];
    
    // Trees/obstacles array
    let trees = [];
    
    // Game map
    const mapWidth = 1920;
    const mapHeight = 1440;
    let cameraX = 0;
    let cameraY = 0;
    
    // Particle system for effects
    let particles = [];
    
    // Ponds array
    let ponds = [];
    
    // Fish array
    let fish = [];
    
    // Enemies array
    let enemies = [];
    
    // Add level-related variables
    let currentLevel = "park";
    let portal = null;
    let levelComplete = false;
    
    // Add total score variable
    let totalScore = 0;
    
    // Create ponds
    function initPonds() {
      ponds = [];
      const minPondDistance = 200; // Minimum distance between ponds
      
      for (let i = 0; i < 5; i++) {
        let validPosition = false;
        let attempts = 0;
        const maxAttempts = 50;
        let newPond;
        
        while (!validPosition && attempts < maxAttempts) {
          attempts++;
          newPond = {
            x: Math.random() * (mapWidth - 200),
            y: Math.random() * (mapHeight - 200),
            width: 100 + Math.random() * 100,
            height: 100 + Math.random() * 100
          };
          
          validPosition = true;
          
          // Check distance from other ponds
          for (const pond of ponds) {
            const dx = newPond.x - pond.x;
            const dy = newPond.y - pond.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            if (distance < minPondDistance) {
              validPosition = false;
              break;
            }
          }
        }
        
        if (validPosition) {
          ponds.push(newPond);
        }
      }
    }
    
    // Create fish
    function spawnFish() {
      if (fish.length < 20 && Math.random() < 0.02) {
        const pond = ponds[Math.floor(Math.random() * ponds.length)];
        const newFish = {
          x: pond.x + Math.random() * pond.width,
          y: pond.y + Math.random() * pond.height,
          size: 16,
          speed: 1 + Math.random() * 0.5,
          direction: Math.random() * Math.PI * 2,
          pondIndex: ponds.indexOf(pond)
        };
        fish.push(newFish);
      }
    }
    
    // Create trees
    function initTrees() {
      trees = [];
      const minTreeDistance = 50; // Minimum distance between trees
      
      for (let i = 0; i < 15; i++) {
        let validPosition = false;
        let attempts = 0;
        const maxAttempts = 50;
        let newTree;
        
        while (!validPosition && attempts < maxAttempts) {
          attempts++;
          newTree = {
            x: Math.random() * (mapWidth - 64),
            y: Math.random() * (mapHeight - 64),
            width: 48 + Math.random() * 16,
            height: 48 + Math.random() * 16
          };
          
          validPosition = true;
          
          // Check if tree overlaps with any pond
          for (const pond of ponds) {
            if (collision(
              newTree.x, newTree.y, newTree.width, newTree.height,
              pond.x, pond.y, pond.width, pond.height
            )) {
              validPosition = false;
              break;
            }
            
            // Also check for minimum distance from pond edges
            const margin = 32;
            if (newTree.x < pond.x + pond.width + margin &&
                newTree.x + newTree.width > pond.x - margin &&
                newTree.y < pond.y + pond.height + margin &&
                newTree.y + newTree.height > pond.y - margin) {
              validPosition = false;
              break;
            }
          }
          
          // Check distance from other trees
          if (validPosition) {
            for (const tree of trees) {
              if (collision(
                newTree.x, newTree.y, newTree.width, newTree.height,
                tree.x, tree.y, tree.width, tree.height
              )) {
                validPosition = false;
                break;
              }
            }
          }
        }
        
        if (validPosition) {
          trees.push(newTree);
        }
      }
    }
    
    // Create victims
    function spawnVictims(count) {
      for (let i = 0; i < count; i++) {
        let x, y;
        let validPosition = false;
        
        while (!validPosition) {
          x = Math.random() * (canvas.width - 30);
          y = Math.random() * (canvas.height - 30);
          validPosition = true;
          
          // Check collision with trees
          for (const tree of trees) {
            if (collision(x, y, 30, 30, tree.x, tree.y, tree.size, tree.size)) {
              validPosition = false;
              break;
            }
          }
          
          // Check collision with ponds
          for (const pond of ponds) {
            if (collision(x, y, 30, 30, pond.x, pond.y, pond.size, pond.size)) {
              validPosition = false;
              break;
            }
          }
        }
        
        victims.push({
          x: x,
          y: y,
          size: 30,
          speed: 1,
          direction: Math.random() * Math.PI * 2,
          directionChangeTime: 0,
          state: 'wandering',
          sprites: {
            frameCount: 0,
            frameDelay: 10,
            currentFrame: 0,
            totalFrames: 2
          }
        });
      }
    }
    
    // Create enemies
    function spawnEnemies() {
      if (enemies.length < 5 && Math.random() < 0.01) {
        const enemyTypes = ['wolf', 'raccoon'];
        const type = enemyTypes[Math.floor(Math.random() * enemyTypes.length)];
        const baseSpeed = type === 'wolf' ? 2 : 1.5;
        
        const newEnemy = {
          x: Math.random() * mapWidth,
          y: Math.random() * mapHeight,
          size: type === 'wolf' ? 32 : 24,
          speed: baseSpeed,
          type: type,
          direction: Math.random() * Math.PI * 2,
          state: 'chasing', // chasing, fleeing
          sprites: {
            frameCount: 0,
            frameDelay: 10,
            currentFrame: 0,
            totalFrames: 2
          }
        };
        
        // Make sure enemies don't spawn on trees, ponds, or other entities
        let validPosition = false;
        let attempts = 0;
        const maxAttempts = 50;
        
        while (!validPosition && attempts < maxAttempts) {
          validPosition = true;
          attempts++;
          
          // Check tree collisions
          for (const tree of trees) {
            if (collision(
              newEnemy.x, newEnemy.y, newEnemy.size, newEnemy.size,
              tree.x, tree.y, tree.width, tree.height
            )) {
              validPosition = false;
              break;
            }
          }
          
          // Check pond collisions
          if (validPosition) {
            const corners = [
              { x: newEnemy.x, y: newEnemy.y },
              { x: newEnemy.x + newEnemy.size, y: newEnemy.y },
              { x: newEnemy.x, y: newEnemy.y + newEnemy.size },
              { x: newEnemy.x + newEnemy.size, y: newEnemy.y + newEnemy.size }
            ];
            
            for (const corner of corners) {
              if (isInPond(corner.x, corner.y)) {
                validPosition = false;
                break;
              }
            }
          }
          
          if (!validPosition) {
            newEnemy.x = Math.random() * mapWidth;
            newEnemy.y = Math.random() * mapHeight;
          }
        }
        
        if (validPosition) {
          enemies.push(newEnemy);
        }
      }
    }
    
    // Draw player
    function drawPlayer() {
      if (player.isFlickering && Math.floor(player.flickerCount / 3) % 2 === 0) {
        return;
      }
      
      // Draw shadow
      ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
      ctx.fillRect(
        player.x - cameraX + 4, 
        player.y - cameraY + 4, 
        player.size + player.pulseSize, 
        player.size + player.pulseSize
      );
      
      // Draw cube with pixelated effect
      ctx.fillStyle = player.color;
      
      // Create pixelated cube effect
      const pixelSize = 4;
      const baseSize = player.size + player.pulseSize;
      
      for (let y = 0; y < baseSize; y += pixelSize) {
        for (let x = 0; x < baseSize; x += pixelSize) {
          // Skip some pixels for texture
          if (Math.random() > 0.9) continue;
          
          // Vary colors slightly for texture
          const colorVariation = Math.floor(Math.random() * 30) - 15;
          ctx.fillStyle = player.hasSpeedBoost ? 
            `rgb(${255 + colorVariation}, ${255 + colorVariation}, ${0 + colorVariation})` :
            `rgb(${255 + colorVariation}, ${0 + colorVariation}, ${0 + colorVariation})`;
          
          ctx.fillRect(
            player.x - cameraX + x, 
            player.y - cameraY + y, 
            pixelSize, 
            pixelSize
          );
        }
      }
      
      // Pulsing glow effect
      ctx.shadowColor = player.hasSpeedBoost ? '#ffff00' : '#ff0000';
      ctx.shadowBlur = 20;
      ctx.beginPath();
      ctx.rect(
        player.x - cameraX, 
        player.y - cameraY, 
        player.size + player.pulseSize, 
        player.size + player.pulseSize
      );
      ctx.fillStyle = player.hasSpeedBoost ? 'rgba(255, 255, 0, 0.5)' : 'rgba(255, 0, 0, 0.5)';
      ctx.fill();
      ctx.shadowBlur = 0;
    }
    
    // Draw victims
    function drawVictims() {
      victims.forEach(victim => {
        // Draw shadow
        ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
        ctx.fillRect(
          victim.x - cameraX + 2, 
          victim.y - cameraY + 2, 
          victim.size, 
          victim.size
        );
        
        // Draw victim with 8-bit style
        const pixelSize = 4;
        
        // Body
        ctx.fillStyle = '#3366cc';
        for (let y = 0; y < victim.size; y += pixelSize) {
          for (let x = 0; x < victim.size; x += pixelSize) {
            // Skip some pixels for a more pixelated look
            if (x > 0 && x < victim.size - pixelSize && y > 0 && y < victim.size - pixelSize) {
              if (Math.random() > 0.9) continue;
              
              ctx.fillRect(
                victim.x - cameraX + x, 
                victim.y - cameraY + y, 
                pixelSize, 
                pixelSize
              );
            }
          }
        }
        
        // Head
        ctx.fillStyle = '#ffccaa';
        ctx.fillRect(
          victim.x - cameraX + 8, 
          victim.y - cameraY + 4, 
          8, 
          8
        );
        
        // Different frames for walking animation
        if (victim.sprites.currentFrame === 0) {
          // Legs position 1
          ctx.fillStyle = '#3366cc';
          ctx.fillRect(
            victim.x - cameraX + 8, 
            victim.y - cameraY + victim.size - 8, 
            4, 
            8
          );
          ctx.fillRect(
            victim.x - cameraX + 16, 
            victim.y - cameraY + victim.size - 8, 
            4, 
            8
          );
        } else {
          // Legs position 2
          ctx.fillStyle = '#3366cc';
          ctx.fillRect(
            victim.x - cameraX + 12, 
            victim.y - cameraY + victim.size - 8, 
            4, 
            8
          );
          ctx.fillRect(
            victim.x - cameraX + 20, 
            victim.y - cameraY + victim.size - 8, 
            4, 
            8
          );
        }
        
        // Animation frame update
        victim.sprites.frameCount++;
        if (victim.sprites.frameCount >= victim.sprites.frameDelay) {
          victim.sprites.frameCount = 0;
          victim.sprites.currentFrame = (victim.sprites.currentFrame + 1) % victim.sprites.totalFrames;
        }
      });
    }
    
    // Draw trees and obstacles
    function drawTrees() {
      trees.forEach(tree => {
        // Check if tree is visible on screen
        if (
          tree.x + tree.width < cameraX ||
          tree.x > cameraX + canvas.width ||
          tree.y + tree.height < cameraY ||
          tree.y > cameraY + canvas.height
        ) {
          return;
        }
        
        // Tree trunk
        ctx.fillStyle = '#663300';
        ctx.fillRect(
          tree.x - cameraX + tree.width / 3, 
          tree.y - cameraY + tree.height / 2, 
          tree.width / 3, 
          tree.height / 2
        );
        
        // Tree foliage (pixelated style)
        const pixelSize = 4;
        ctx.fillStyle = '#006600';
        
        for (let y = 0; y < tree.height / 2; y += pixelSize) {
          for (let x = 0; x < tree.width; x += pixelSize) {
            // Create a circular/blob shape for the foliage
            const centerX = tree.width / 2;
            const centerY = tree.height / 4;
            const distance = Math.sqrt(Math.pow(x - centerX, 2) + Math.pow(y - centerY, 2));
            
            if (distance < tree.width / 2.5) {
              // Skip some pixels for texture
              if (Math.random() > 0.9) continue;
              
              // Vary colors slightly for texture
              const colorVariation = Math.floor(Math.random() * 30) - 15;
              ctx.fillStyle = `rgb(${0 + colorVariation}, ${102 + colorVariation}, ${0 + colorVariation})`;
              
              ctx.fillRect(
                tree.x - cameraX + x, 
                tree.y - cameraY + y, 
                pixelSize, 
                pixelSize
              );
            }
          }
        }
      });
    }
    
    // Draw ponds and fish
    function drawPonds() {
      ponds.forEach(pond => {
        // Check if pond is visible on screen
        if (
          pond.x + pond.width < cameraX ||
          pond.x > cameraX + canvas.width ||
          pond.y + pond.height < cameraY ||
          pond.y > cameraY + canvas.height
        ) {
          return;
        }
        
        // Draw pond water
        ctx.fillStyle = '#0066cc';
        ctx.fillRect(
          pond.x - cameraX,
          pond.y - cameraY,
          pond.width,
          pond.height
        );
        
        // Draw pond edge
        ctx.fillStyle = '#003366';
        ctx.fillRect(
          pond.x - cameraX,
          pond.y - cameraY,
          pond.width,
          4
        );
        ctx.fillRect(
          pond.x - cameraX,
          pond.y - cameraY,
          4,
          pond.height
        );
        ctx.fillRect(
          pond.x - cameraX + pond.width - 4,
          pond.y - cameraY,
          4,
          pond.height
        );
        ctx.fillRect(
          pond.x - cameraX,
          pond.y - cameraY + pond.height - 4,
          pond.width,
          4
        );
      });
      
      // Draw fish
      fish.forEach(fish => {
        // Check if fish is visible on screen
        if (
          fish.x + fish.size < cameraX ||
          fish.x > cameraX + canvas.width ||
          fish.y + fish.size < cameraY ||
          fish.y > cameraY + canvas.height
        ) {
          return;
        }
        
        // Draw fish shadow
        ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
        ctx.fillRect(
          fish.x - cameraX + 2,
          fish.y - cameraY + 2,
          fish.size,
          fish.size
        );
        
        // Draw fish body
        ctx.fillStyle = '#ff9900';
        ctx.fillRect(
          fish.x - cameraX,
          fish.y - cameraY,
          fish.size,
          fish.size
        );
        
        // Draw fish tail
        ctx.fillStyle = '#ff6600';
        ctx.fillRect(
          fish.x - cameraX + fish.size - 4,
          fish.y - cameraY + 4,
          8,
          8
        );
      });
    }
    
    // Draw enemies
    function drawEnemies() {
      enemies.forEach(enemy => {
        // Draw shadow
        ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
        ctx.fillRect(
          enemy.x - cameraX + 2,
          enemy.y - cameraY + 2,
          enemy.size,
          enemy.size
        );
        
        const x = enemy.x - cameraX;
        const y = enemy.y - cameraY;
        const size = enemy.size;
        const isWolf = enemy.type === 'wolf';
        
        // Calculate direction for body parts
        const bodyAngle = enemy.direction;
        const legOffset = Math.PI / 4; // 45 degrees for legs
        
        // Draw body (main rectangle)
        ctx.save();
        ctx.translate(x + size/2, y + size/2);
        ctx.rotate(bodyAngle);
        
        // Body
        ctx.fillStyle = isWolf ? '#666666' : '#8B4513';
        ctx.fillRect(-size/2, -size/3, size, size/2);
        
        // Head
        ctx.fillStyle = isWolf ? '#666666' : '#8B4513';
        ctx.beginPath();
        ctx.arc(size/2, -size/3, size/3, 0, Math.PI * 2);
        ctx.fill();
        
        // Ears
        ctx.fillStyle = isWolf ? '#666666' : '#8B4513';
        ctx.beginPath();
        ctx.arc(size/2 + size/4, -size/2, size/6, 0, Math.PI * 2);
        ctx.arc(size/2 + size/4, -size/3, size/6, 0, Math.PI * 2);
        ctx.fill();
        
        // Eyes
        ctx.fillStyle = '#ff0000';
        ctx.beginPath();
        ctx.arc(size/2 + size/4, -size/3, 2, 0, Math.PI * 2);
        ctx.arc(size/2 + size/4, -size/4, 2, 0, Math.PI * 2);
        ctx.fill();
        
        // Snout
        ctx.fillStyle = isWolf ? '#666666' : '#8B4513';
        ctx.beginPath();
        ctx.arc(size/2 + size/3, -size/3, size/6, 0, Math.PI * 2);
        ctx.fill();
        
        // Legs
        ctx.fillStyle = isWolf ? '#666666' : '#8B4513';
        
        // Front legs
        ctx.save();
        ctx.rotate(legOffset);
        ctx.fillRect(-size/4, -size/3, size/4, size/2);
        ctx.restore();
        
        ctx.save();
        ctx.rotate(-legOffset);
        ctx.fillRect(-size/4, -size/3, size/4, size/2);
        ctx.restore();
        
        // Back legs
        ctx.save();
        ctx.rotate(legOffset + Math.PI/2);
        ctx.fillRect(-size/4, -size/3, size/4, size/2);
        ctx.restore();
        
        ctx.save();
        ctx.rotate(-legOffset + Math.PI/2);
        ctx.fillRect(-size/4, -size/3, size/4, size/2);
        ctx.restore();
        
        // Tail
        ctx.fillStyle = isWolf ? '#555555' : '#8B4513';
        ctx.beginPath();
        ctx.arc(-size/2, -size/3, size/4, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.restore();
        
        // Add some texture/detail
        ctx.fillStyle = isWolf ? '#777777' : '#A0522D';
        for (let i = 0; i < 3; i++) {
          ctx.fillRect(
            x + Math.random() * size,
            y + Math.random() * size,
            2,
            2
          );
        }
      });
    }
    
    // Draw the park background
    function drawBackground() {
      // Grid pattern for grass
      const gridSize = 32;
      
      for (let y = Math.floor(cameraY / gridSize) * gridSize; y < cameraY + canvas.height; y += gridSize) {
        for (let x = Math.floor(cameraX / gridSize) * gridSize; x < cameraX + canvas.width; x += gridSize) {
          const screenX = x - cameraX;
          const screenY = y - cameraY;
          
          // Alternate grass colors for pattern
          if ((Math.floor(x / gridSize) + Math.floor(y / gridSize)) % 2 === 0) {
            ctx.fillStyle = '#003300';
          } else {
            ctx.fillStyle = '#004400';
          }
          
          ctx.fillRect(screenX, screenY, gridSize, gridSize);
          
          // Add some random dots for texture
          ctx.fillStyle = '#001100';
          if (Math.random() > 0.7) {
            ctx.fillRect(
              screenX + Math.random() * gridSize, 
              screenY + Math.random() * gridSize, 
              2, 
              2
            );
          }
        }
      }
      
      // Draw upside-down effect for Stranger Things vibe
      if (score > 5) {
        ctx.fillStyle = 'rgba(0, 10, 20, 0.1)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        // Occasional floating particles
        if (Math.random() > 0.95) {
          particles.push({
            x: Math.random() * canvas.width,
            y: canvas.height,
            size: 1 + Math.random() * 3,
            speedY: -1 - Math.random() * 2,
            life: 100 + Math.random() * 100
          });
        }
      }
    }
    
    // Draw particles
    function drawParticles() {
      ctx.fillStyle = '#ccccff';
      particles.forEach(particle => {
        ctx.globalAlpha = particle.life / 200;
        ctx.fillRect(
          particle.x, 
          particle.y, 
          particle.size, 
          particle.size
        );
        ctx.globalAlpha = 1;
      });
    }
    
    // Update particles
    function updateParticles() {
      for (let i = particles.length - 1; i >= 0; i--) {
        particles[i].y += particles[i].speedY;
        particles[i].life--;
        
        if (particles[i].life <= 0) {
          particles.splice(i, 1);
        }
      }
    }
    
    // Check collision between two rectangles
    function collision(x1, y1, w1, h1, x2, y2, w2, h2) {
      return x1 < x2 + w2 &&
             x1 + w1 > x2 &&
             y1 < y2 + h2 &&
             y1 + h1 > y2;
    }
    
    // Check if a point is inside a pond
    function isInPond(x, y) {
      for (const pond of ponds) {
        if (x >= pond.x && x <= pond.x + pond.width &&
            y >= pond.y && y <= pond.y + pond.height) {
          return true;
        }
      }
      return false;
    }
    
    // Check if player is in a pond
    function checkPlayerInPond() {
      const corners = [
        { x: player.x, y: player.y },
        { x: player.x + player.size, y: player.y },
        { x: player.x, y: player.y + player.size },
        { x: player.x + player.size, y: player.y + player.size }
      ];
      
      for (const corner of corners) {
        if (isInPond(corner.x, corner.y)) {
          player.isInPond = true;
          return;
        }
      }
      player.isInPond = false;
    }
    
    // Update game state
    function update() {
      if (isGameOver) return;
      
      // Update invulnerability timer
      if (player.invulnerabilityTimer > 0) {
        player.invulnerabilityTimer--;
        if (player.invulnerabilityTimer === 0) {
          player.isFlickering = false;
        }
      }
      
      // Update speed boost timer
      if (player.hasSpeedBoost) {
        player.speedBoostTimer--;
        speedBoostDisplay.style.display = 'block';
        boostTimerDisplay.textContent = Math.ceil(player.speedBoostTimer / 60);
        if (player.speedBoostTimer <= 0) {
          player.hasSpeedBoost = false;
          speedBoostDisplay.style.display = 'none';
        }
      }
      
      // Player pulse effect
      player.pulseSize += 0.2 * player.pulseDirection;
      if (player.pulseSize > 4) {
        player.pulseDirection = -1;
      } else if (player.pulseSize < 0) {
        player.pulseDirection = 1;
      }
      
      // Player flickering when low energy
      if (energy < 30) {
        player.isFlickering = true;
        player.flickerCount++;
      } else {
        player.isFlickering = false;
        player.flickerCount = 0;
      }
      
      // Update camera position to follow player
      cameraX = player.x - canvas.width / 2 + player.size / 2;
      cameraY = player.y - canvas.height / 2 + player.size / 2;
      
      // Keep camera within map bounds
      cameraX = Math.max(0, Math.min(mapWidth - canvas.width, cameraX));
      cameraY = Math.max(0, Math.min(mapHeight - canvas.height, cameraY));
      
      // Decrease energy over time
      energy -= 0.05;
      if (energy <= 0) {
        gameOver();
      }
      
      // Update energy display
      energyDisplay.textContent = Math.floor(energy);
      
      // Process victim logic
      for (let i = victims.length - 1; i >= 0; i--) {
        const victim = victims[i];
        
        // Check if player is near and change to fleeing state
        const dx = player.x - victim.x;
        const dy = player.y - victim.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        if (distance < 150 && victim.state === 'wandering') {
          victim.state = 'fleeing';
          victim.speed = 2 + Math.random() * 0.5;
          // Direction away from player
          victim.direction = Math.atan2(dy, dx) + Math.PI;
        }
        
        // Random direction changes for wandering
        if (victim.state === 'wandering') {
          victim.directionChangeTime++;
          if (victim.directionChangeTime > 60) {
            victim.direction += (Math.random() - 0.5) * Math.PI / 2;
            victim.directionChangeTime = 0;
          }
        }
        
        // Move victim
        const newX = victim.x + Math.cos(victim.direction) * victim.speed;
        const newY = victim.y + Math.sin(victim.direction) * victim.speed;
        
        // Check for tree collisions and pond collisions
        let canMove = true;
        
        // Check tree collisions
        for (const tree of trees) {
          if (collision(
            newX, newY, victim.size, victim.size,
            tree.x, tree.y, tree.width, tree.height
          )) {
            canMove = false;
            victim.direction += Math.PI + (Math.random() - 0.5) * Math.PI / 2;
            break;
          }
        }
        
        // Check pond collisions
        if (canMove) {
          const corners = [
            { x: newX, y: newY },
            { x: newX + victim.size, y: newY },
            { x: newX, y: newY + victim.size },
            { x: newX + victim.size, y: newY + victim.size }
          ];
          
          for (const corner of corners) {
            if (isInPond(corner.x, corner.y)) {
              canMove = false;
              victim.direction += Math.PI + (Math.random() - 0.5) * Math.PI / 2;
              break;
            }
          }
        }
        
        // Keep within map bounds
        if (newX < 0 || newX > mapWidth - victim.size) {
          victim.direction = Math.PI - victim.direction;
          canMove = false;
        }
        if (newY < 0 || newY > mapHeight - victim.size) {
          victim.direction = -victim.direction;
          canMove = false;
        }
        
        if (canMove) {
          victim.x = newX;
          victim.y = newY;
        }
        
        // Check for collision with player (eating)
        if (collision(
          player.x, player.y, player.size, player.size,
          victim.x, victim.y, victim.size, victim.size
        )) {
          // Create particle effect for eating
          for (let j = 0; j < 20; j++) {
            particles.push({
              x: victim.x - cameraX + Math.random() * victim.size,
              y: victim.y - cameraY + Math.random() * victim.size,
              size: 2 + Math.random() * 3,
              speedY: -1 - Math.random() * 3,
              life: 60 + Math.random() * 60
            });
          }
          
          // Remove victim and increase score/energy
          victims.splice(i, 1);
          score++;
          energy = Math.min(100, energy + 30);
          
          // Update score display
          scoreDisplay.textContent = score;
          
          // Make player grow slightly with each victim
          if (player.size < 48) {
            player.size += 1;
          }
        }
      }
      
      // Spawn new victims less frequently
      if (Math.random() < 0.01) {
        spawnVictims(1);
      }
      
      // Update particles
      updateParticles();
      
      // Update fish movement
      updateFish();
      
      // Spawn new fish
      spawnFish();

      // Check for fish collisions
      for (let i = fish.length - 1; i >= 0; i--) {
        const currentFish = fish[i];
        if (collision(
          player.x, player.y, player.size, player.size,
          currentFish.x, currentFish.y, currentFish.size, currentFish.size
        )) {
          // Create particle effect for eating fish
          for (let j = 0; j < 15; j++) {
            particles.push({
              x: currentFish.x - cameraX + Math.random() * currentFish.size,
              y: currentFish.y - cameraY + Math.random() * currentFish.size,
              size: 2 + Math.random() * 3,
              speedY: -1 - Math.random() * 3,
              life: 60 + Math.random() * 60
            });
          }
          
          // Remove fish and activate speed boost
          fish.splice(i, 1);
          player.hasSpeedBoost = true;
          player.speedBoostTimer = 600; // 10 seconds at 60fps
        }
      }
      
      // Update enemies
      updateEnemies();
      
      // Spawn new enemies
      spawnEnemies();

      // Check for level completion
      if (!levelComplete && score >= getLevelConfig(currentLevel).requiredVictims) {
        levelComplete = true;
        // Spawn portal at random location in the game world
        let validPosition = false;
        let attempts = 0;
        while (!validPosition && attempts < 50) {
          portal = {
            x: Math.random() * (mapWidth - 60) + 30,
            y: Math.random() * (mapHeight - 60) + 30
          };
          validPosition = true;
          
          // Check collision with trees
          for (let tree of trees) {
            const dx = portal.x - tree.x;
            const dy = portal.y - tree.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            if (distance < tree.width + 40) {
              validPosition = false;
              break;
            }
          }
          
          // Check collision with ponds
          if (validPosition) {
            for (let pond of ponds) {
              const dx = portal.x - pond.x;
              const dy = portal.y - pond.y;
              const distance = Math.sqrt(dx * dx + dy * dy);
              if (distance < pond.width + 40) {
                validPosition = false;
                break;
              }
            }
          }
          
          attempts++;
        }
      }
      
      // Check portal collision
      checkPortalCollision();
    }
    
    // Game over
    function gameOver() {
      isGameOver = true;
      gameOverScreen.style.display = 'block';
      finalScoreDisplay.textContent = totalScore;
    }
    
    // Restart game
    function restartGame() {
      score = 0;
      totalScore = 0;
      energy = 100;
      isGameOver = false;
      gameTime = 0;
      player.x = canvas.width / 2;
      player.y = canvas.height / 2;
      player.size = 32;
      player.hasSpeedBoost = false;
      player.speedBoostTimer = 0;
      player.invulnerabilityTimer = 0;
      victims = [];
      enemies = [];
      fish = [];
      particles = [];
      scoreDisplay.textContent = '0';
      energyDisplay.textContent = '100';
      document.getElementById('totalScore').textContent = '0';
      speedBoostDisplay.style.display = 'none';
      gameOverScreen.style.display = 'none';
      currentLevel = "park";
      initLevel(currentLevel);
    }
    
    // Draw everything
    function draw() {
      // Clear canvas
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      // Draw game elements
      drawBackground();
      drawTrees();
      drawPonds();
      drawVictims();
      drawEnemies();
      drawPlayer();
      drawParticles();
      
      // Draw portal
      drawPortal();
      
      // Draw portal direction indicator if portal exists
      if (portal) {
        drawPortalIndicator();
      }
    }
    
    // Add portal direction indicator function
    function drawPortalIndicator() {
      const centerX = canvas.width / 2;
      const centerY = canvas.height / 2;
      
      // Calculate angle to portal
      const dx = portal.x - player.x;
      const dy = portal.y - player.y;
      const angle = Math.atan2(dy, dx);
      
      // Draw arrow
      ctx.save();
      ctx.translate(centerX, centerY);
      ctx.rotate(angle);
      
      // Draw arrow shaft
      ctx.fillStyle = "#FF00FF";
      ctx.fillRect(0, -4, 100, 8);
      
      // Draw arrow head
      ctx.beginPath();
      ctx.moveTo(100, 0);
      ctx.lineTo(80, -15);
      ctx.lineTo(80, 15);
      ctx.closePath();
      ctx.fill();
      
      ctx.restore();
      
      // Draw distance text
      const distance = Math.sqrt(dx * dx + dy * dy);
      ctx.fillStyle = "#FF00FF";
      ctx.font = "16px Arial";
      ctx.fillText(`Portal: ${Math.floor(distance)}px`, centerX - 40, centerY - 20);
    }

    // Add portal drawing function
    function drawPortal() {
      if (!portal) return;
      
      ctx.save();
      ctx.translate(portal.x - cameraX, portal.y - cameraY);
      
      // Draw portal ring
      ctx.beginPath();
      ctx.arc(0, 0, 30, 0, Math.PI * 2);
      ctx.fillStyle = "#FF00FF";
      ctx.fill();
      ctx.strokeStyle = "#FFFFFF";
      ctx.lineWidth = 4;
      ctx.stroke();
      
      // Draw portal effect
      ctx.beginPath();
      ctx.arc(0, 0, 25, 0, Math.PI * 2);
      ctx.fillStyle = "#00FFFF";
      ctx.fill();
      
      // Draw portal particles
      for (let i = 0; i < 5; i++) {
        const angle = Math.random() * Math.PI * 2;
        const radius = Math.random() * 20;
        const x = Math.cos(angle) * radius;
        const y = Math.sin(angle) * radius;
        
        ctx.beginPath();
        ctx.arc(x, y, 2, 0, Math.PI * 2);
        ctx.fillStyle = "#FFFFFF";
        ctx.fill();
      }
      
      ctx.restore();
    }

    // Add portal collision check
    function checkPortalCollision() {
      if (!portal || !levelComplete) return;
      
      const dx = player.x - portal.x;
      const dy = player.y - portal.y;
      const distance = Math.sqrt(dx * dx + dy * dy);
      
      if (distance < 40) {
        const nextLevel = getNextLevel(currentLevel);
        if (nextLevel) {
          // Add current level score to total
          totalScore += score;
          // Reset score for the new level
          score = 0;
          scoreDisplay.textContent = '0';
          // Update current level
          currentLevel = nextLevel;
          // Initialize the new level
          initLevel(currentLevel);
          // Update level name display
          document.getElementById('levelName').textContent = getLevelConfig(currentLevel).name;
          // Reset level complete flag
          levelComplete = false;
        } else {
          // Game complete
          isGameOver = true;
          gameOverScreen.style.display = 'block';
          finalScoreDisplay.textContent = totalScore;
        }
      }
    }

    // Add spawnTrees function
    function spawnTrees(count) {
      trees = [];
      const minTreeDistance = 50; // Minimum distance between trees
      
      for (let i = 0; i < count; i++) {
        let validPosition = false;
        let attempts = 0;
        const maxAttempts = 50;
        let newTree;
        
        while (!validPosition && attempts < maxAttempts) {
          attempts++;
          newTree = {
            x: Math.random() * (mapWidth - 64),
            y: Math.random() * (mapHeight - 64),
            width: 48 + Math.random() * 16,
            height: 48 + Math.random() * 16
          };
          
          validPosition = true;
          
          // Check if tree overlaps with any pond
          for (const pond of ponds) {
            if (collision(
              newTree.x, newTree.y, newTree.width, newTree.height,
              pond.x, pond.y, pond.width, pond.height
            )) {
              validPosition = false;
              break;
            }
            
            // Also check for minimum distance from pond edges
            const margin = 32;
            if (newTree.x < pond.x + pond.width + margin &&
                newTree.x + newTree.width > pond.x - margin &&
                newTree.y < pond.y + pond.height + margin &&
                newTree.y + newTree.height > pond.y - margin) {
              validPosition = false;
              break;
            }
          }
          
          // Check distance from other trees
          if (validPosition) {
            for (const tree of trees) {
              if (collision(
                newTree.x, newTree.y, newTree.width, newTree.height,
                tree.x, tree.y, tree.width, tree.height
              )) {
                validPosition = false;
                break;
              }
            }
          }
        }
        
        if (validPosition) {
          trees.push(newTree);
        }
      }
    }

    // Add spawnPonds function
    function spawnPonds(count, size) {
      ponds = [];
      const minPondDistance = 200; // Minimum distance between ponds
      
      for (let i = 0; i < count; i++) {
        let validPosition = false;
        let attempts = 0;
        const maxAttempts = 50;
        let newPond;
        
        while (!validPosition && attempts < maxAttempts) {
          attempts++;
          newPond = {
            x: Math.random() * (mapWidth - size),
            y: Math.random() * (mapHeight - size),
            width: size,
            height: size
          };
          
          validPosition = true;
          
          // Check distance from other ponds
          for (const pond of ponds) {
            const dx = newPond.x - pond.x;
            const dy = newPond.y - pond.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            if (distance < minPondDistance) {
              validPosition = false;
              break;
            }
          }
        }
        
        if (validPosition) {
          ponds.push(newPond);
        }
      }
    }

    // Add spawnEnemy function
    function spawnEnemy(enemyType) {
      let validPosition = false;
      let attempts = 0;
      const maxAttempts = 50;
      let newEnemy;
      
      while (!validPosition && attempts < maxAttempts) {
        attempts++;
        newEnemy = {
          x: Math.random() * (mapWidth - enemyType.size),
          y: Math.random() * (mapHeight - enemyType.size),
          size: enemyType.size,
          speed: enemyType.speed,
          type: enemyType.type,
          state: 'chasing',
          sprites: {
            frameCount: 0,
            frameDelay: 10,
            currentFrame: 0,
            totalFrames: 2
          }
        };
        
        validPosition = true;
        
        // Check tree collisions
        for (const tree of trees) {
          if (collision(
            newEnemy.x, newEnemy.y, newEnemy.size, newEnemy.size,
            tree.x, tree.y, tree.width, tree.height
          )) {
            validPosition = false;
            break;
          }
        }
        
        // Check pond collisions
        if (validPosition) {
          const corners = [
            { x: newEnemy.x, y: newEnemy.y },
            { x: newEnemy.x + newEnemy.size, y: newEnemy.y },
            { x: newEnemy.x, y: newEnemy.y + newEnemy.size },
            { x: newEnemy.x + newEnemy.size, y: newEnemy.y + newEnemy.size }
          ];
          
          for (const corner of corners) {
            if (isInPond(corner.x, corner.y)) {
              validPosition = false;
              break;
            }
          }
        }
      }
      
      if (validPosition) {
        enemies.push(newEnemy);
      }
    }

    // Add updateHUD function
    function updateHUD() {
      scoreDisplay.textContent = score;
      energyDisplay.textContent = Math.floor(energy);
      if (player.hasSpeedBoost) {
        speedBoostDisplay.style.display = 'block';
        boostTimerDisplay.textContent = Math.ceil(player.speedBoostTimer / 60);
      } else {
        speedBoostDisplay.style.display = 'none';
      }
    }

    // Add updateFish function
    function updateFish() {
      for (let i = fish.length - 1; i >= 0; i--) {
        const currentFish = fish[i];
        const pond = ponds[currentFish.pondIndex];
        
        // Move fish
        currentFish.x += Math.cos(currentFish.direction) * currentFish.speed;
        currentFish.y += Math.sin(currentFish.direction) * currentFish.speed;
        
        // Check if fish is still in its pond
        if (currentFish.x < pond.x || currentFish.x > pond.x + pond.width ||
            currentFish.y < pond.y || currentFish.y > pond.y + pond.height) {
          // Fish is out of pond, make it turn back
          const centerX = pond.x + pond.width / 2;
          const centerY = pond.y + pond.height / 2;
          currentFish.direction = Math.atan2(centerY - currentFish.y, centerX - currentFish.x);
        }
        
        // Random direction changes
        if (Math.random() < 0.02) {
          currentFish.direction += (Math.random() - 0.5) * Math.PI / 4;
        }
      }
    }

    // Add updateEnemies function
    function updateEnemies() {
      for (let i = enemies.length - 1; i >= 0; i--) {
        const enemy = enemies[i];
        
        // Calculate distance to player
        const dx = player.x - enemy.x;
        const dy = player.y - enemy.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        // Update enemy state based on distance to player
        if (distance < 200 && enemy.state === 'chasing') {
          // Enemy is close to player, chase them
          enemy.direction = Math.atan2(dy, dx);
        } else if (distance > 300 && enemy.state === 'fleeing') {
          // Enemy is far from player, return to chasing
          enemy.state = 'chasing';
        }
        
        // Move enemy
        const speed = enemy.state === 'chasing' ? enemy.speed : enemy.speed * 0.5;
        const newX = enemy.x + Math.cos(enemy.direction) * speed;
        const newY = enemy.y + Math.sin(enemy.direction) * speed;
        
        // Check for collisions before moving
        let canMove = true;
        
        // Check tree collisions
        for (const tree of trees) {
          if (collision(
            newX, newY, enemy.size, enemy.size,
            tree.x, tree.y, tree.width, tree.height
          )) {
            canMove = false;
            enemy.direction += Math.PI + (Math.random() - 0.5) * Math.PI / 2;
            break;
          }
        }
        
        // Check pond collisions
        if (canMove) {
          const corners = [
            { x: newX, y: newY },
            { x: newX + enemy.size, y: newY },
            { x: newX, y: newY + enemy.size },
            { x: newX + enemy.size, y: newY + enemy.size }
          ];
          
          for (const corner of corners) {
            if (isInPond(corner.x, corner.y)) {
              canMove = false;
              enemy.direction += Math.PI + (Math.random() - 0.5) * Math.PI / 2;
              break;
            }
          }
        }
        
        // Keep within map bounds
        if (newX < 0 || newX > mapWidth - enemy.size) {
          enemy.direction = Math.PI - enemy.direction;
          canMove = false;
        }
        if (newY < 0 || newY > mapHeight - enemy.size) {
          enemy.direction = -enemy.direction;
          canMove = false;
        }
        
        if (canMove) {
          enemy.x = newX;
          enemy.y = newY;
        }
        
        // Check for collision with player
        if (collision(
          player.x, player.y, player.size, player.size,
          enemy.x, enemy.y, enemy.size, enemy.size
        )) {
          if (player.hasSpeedBoost) {
            // Player can eat enemy with speed boost
            // Create particle effect for eating enemy
            for (let j = 0; j < 15; j++) {
              particles.push({
                x: enemy.x - cameraX + Math.random() * enemy.size,
                y: enemy.y - cameraY + Math.random() * enemy.size,
                size: 2 + Math.random() * 3,
                speedY: -1 - Math.random() * 3,
                life: 30 + Math.random() * 30
              });
            }
            
            // Remove enemy and increase score
            enemies.splice(i, 1);
            score++;
            scoreDisplay.textContent = score;
          } else if (player.invulnerabilityTimer === 0) {
            // Player takes damage
            energy -= 20;
            player.invulnerabilityTimer = 60; // 1 second of invulnerability
            player.isFlickering = true;
            
            // Create particle effect for damage
            for (let j = 0; j < 10; j++) {
              particles.push({
                x: player.x - cameraX + Math.random() * player.size,
                y: player.y - cameraY + Math.random() * player.size,
                size: 2 + Math.random() * 3,
                speedY: -1 - Math.random() * 3,
                life: 30 + Math.random() * 30
              });
            }
            
            // Enemy flees after attacking
            enemy.state = 'fleeing';
            enemy.direction = Math.atan2(-dy, -dx);
          }
        }
        
        // Update animation frame
        enemy.sprites.frameCount++;
        if (enemy.sprites.frameCount >= enemy.sprites.frameDelay) {
          enemy.sprites.frameCount = 0;
          enemy.sprites.currentFrame = (enemy.sprites.currentFrame + 1) % enemy.sprites.totalFrames;
        }
      }
    }

    // Add level initialization function
    function initLevel(levelName) {
      // Reset game state
      trees = [];
      ponds = [];
      victims = [];
      enemies = [];
      fish = [];
      portal = null;
      levelComplete = false;
      
      // Get level configuration
      const config = getLevelConfig(levelName);
      
      // Set background color
      document.body.style.backgroundColor = config.background;
      
      // Spawn trees
      spawnTrees(config.treeCount);
      
      // Spawn ponds
      spawnPonds(config.pondCount, config.pondSize);
      
      // Spawn victims
      spawnVictims(config.victimCount);
      
      // Spawn enemies based on level configuration
      config.enemyTypes.forEach(enemyType => {
        for (let i = 0; i < enemyType.count; i++) {
          enemies.push({
            x: Math.random() * (canvas.width - enemyType.size),
            y: Math.random() * (canvas.height - enemyType.size),
            size: enemyType.size,
            speed: enemyType.speed,
            type: enemyType.type,
            state: 'chasing',
            direction: Math.random() * Math.PI * 2,
            sprites: {
              frameCount: 0,
              frameDelay: 10,
              currentFrame: 0,
              totalFrames: 2
            }
          });
        }
      });
      
      // Spawn fish in ponds
      ponds.forEach(pond => {
        spawnFish(pond);
      });
    }

    // Game loop
    function gameLoop() {
      if (!isGameOver) {
        // Check if player is in pond
        checkPlayerInPond();
        
        // Calculate current player speed
        let currentSpeed = player.speed;
        if (player.isInPond) {
          currentSpeed *= 0.5;
        }
        if (player.hasSpeedBoost) {
          currentSpeed *= 1.5;
        }
        
        // Handle keyboard input
        if (keys.ArrowUp || keys.w) {
          const newY = player.y - currentSpeed;
          let canMove = true;
          
          // Check for tree collisions
          for (const tree of trees) {
            if (collision(
              player.x, newY, player.size, player.size,
              tree.x, tree.y, tree.width, tree.height
            )) {
              canMove = false;
              break;
            }
          }
          
          if (canMove && newY >= 0) {
            player.y = newY;
          }
        }
        if (keys.ArrowDown || keys.s) {
          const newY = player.y + currentSpeed;
          let canMove = true;
          
          // Check for tree collisions
          for (const tree of trees) {
            if (collision(
              player.x, newY, player.size, player.size,
              tree.x, tree.y, tree.width, tree.height
            )) {
              canMove = false;
              break;
            }
          }
          
          if (canMove && newY <= mapHeight - player.size) {
            player.y = newY;
          }
        }
        if (keys.ArrowLeft || keys.a) {
          const newX = player.x - currentSpeed;
          let canMove = true;
          
          // Check for tree collisions
          for (const tree of trees) {
            if (collision(
              newX, player.y, player.size, player.size,
              tree.x, tree.y, tree.width, tree.height
            )) {
              canMove = false;
              break;
            }
          }
          
          if (canMove && newX >= 0) {
            player.x = newX;
          }
        }
        if (keys.ArrowRight || keys.d) {
          const newX = player.x + currentSpeed;
          let canMove = true;
          
          // Check for tree collisions
          for (const tree of trees) {
            if (collision(
              newX, player.y, player.size, player.size,
              tree.x, tree.y, tree.width, tree.height
            )) {
              canMove = false;
              break;
            }
          }
          
          if (canMove && newX <= mapWidth - player.size) {
            player.x = newX;
          }
        }
        
        update();
      }
      
      draw();
      requestAnimationFrame(gameLoop);
    }
    
    // Handle keyboard input
    const keys = {};
    
    window.addEventListener('keydown', (e) => {
      keys[e.key] = true;
    });
    
    window.addEventListener('keyup', (e) => {
      keys[e.key] = false;
    });
    
    // Initialize game
    function initGame() {
      initTrees();
      initPonds();
      spawnVictims(1);
      gameLoop();
    }
    
    // Start game
    initGame();
    
    // Make restart function globally available
    window.restartGame = restartGame;

    // Initialize first level
    initLevel(currentLevel);
  </script>
</body>
</html> 